'use strict';

var mongodb = require('mongodb');

function parseMongoDBConnectionString(connectionString) {
    const url = new URL(connectionString);
    const database = url.pathname.slice(1);
    url.pathname = '/';
    return {
        database,
        linkWithoutDatabase: url.toString(),
    };
}
class MongoAdapter {
    constructor(connectionString, { collection, multipleCollections }) {
        Object.defineProperty(this, "collection", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "multipleCollections", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "mongoUrl", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "databaseName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "db", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.collection = collection;
        this.multipleCollections = multipleCollections;
        const connectionParams = parseMongoDBConnectionString(connectionString);
        this.mongoUrl = connectionParams.linkWithoutDatabase;
        this.databaseName = connectionParams.database;
        this.client = new mongodb.MongoClient(this.mongoUrl);
        this.db = this.client.db(this.databaseName);
    }
    _getCollectionName({ docName }) {
        if (!docName && this.multipleCollections) {
            throw new Error('_getCollectionName: docName must be provided when multipleCollections is true');
        }
        if (this.multipleCollections) {
            return docName;
        }
        else {
            return this.collection;
        }
    }
    get(query) {
        const collection = this.db.collection(this._getCollectionName(query));
        return collection.findOne(query);
    }
    async put(query, values) {
        if (!query.docName || !query.version || !values.value) {
            throw new Error('Document and version must be provided');
        }
        const collection = this.db.collection(this._getCollectionName(query));
        await collection.updateOne(query, { $set: values }, { upsert: true });
        return this.get(query);
    }
    del(query) {
        const collection = this.db.collection(this._getCollectionName(query));
        const bulk = collection.initializeOrderedBulkOp();
        bulk.find(query).delete();
        return bulk.execute();
    }
    readAsCursor(query, opts = {}) {
        const { limit = 0, reverse = false } = opts;
        const collection = this.db.collection(this._getCollectionName(query));
        const sortQuery = reverse
            ? { clock: -1, part: 1 }
            : { clock: 1, part: 1 };
        const curs = collection.find(query).sort(sortQuery).limit(limit);
        return curs;
    }
    async close() {
        await this.client.close();
    }
    async getCollectionNames() {
        const collectionInfos = await this.db.listCollections().toArray();
        return collectionInfos.map((c) => c.name);
    }
    async flush() {
        await this.db.dropDatabase();
        await this.client.close();
    }
    dropCollection(collectionName) {
        return this.db.collection(collectionName).drop();
    }
}

exports.MongoAdapter = MongoAdapter;
//# sourceMappingURL=mongo-adapter.cjs.map
